main: Seed the randomness of the program. Place clearings, place tall grass, place border boulders, place exits, place paths, place buildings, fill blank space, and print the generated map. All in that exact order.

place_clearings: This operates by verifying that 2 disctinct clearings have been generated. While the number of clearings counted is less than 2, this function will continue to execute.
A random height and length is generated between 12 and 3. Before we place down a clearing, we check to see if we are going to overlap with another. If we are going to overlap, don't place the clearing, and try again. If we aren't going to overlap, place the clearing, and move on to the next clearing.
* There is an outcome where we get stuck in this phase, if we fill up the whole 2-D array with clearing. However, in all of my testing, it did not happen once. So, for the purposes of this assignment, I'm not going to change it.

place_tall_grass: Operates almost identically to place_clearings, but instead verifies that 2 distinct tall grass regions have been placed.
* This executes after place_clearings, so we might accidentally end up with a single clearing (overwrite an existing clearing). However, just looking at my maps generated by my algorithm, I think this is fairly acceptable. All of the maps I've generated have 2 groups of periods and 2 groups of commans, even if they are really small, or just seperated by a road.

place_border_boulders: Place unmovable rocks on the edges of the array. Creates a playing area that has 21 x 80 ASCII spaces of area.

place_exits: Choose 4 random spots on the edges of the 21 x 80 playing area for the user to exit this area.
* The exits needed to allow 3 spaces on the edges at minimum to make building placement easier. So, the exits were actually placed in a 18 x 77 area.

place_paths: Place the paths that connect the exits. Start with connecting up and down paths. Build towards a random row of the map. This random row also must be within the 18 x 77 area, to ease building placement. Once we have built the paths up / down, we will connect them depending on whether the top exit is rightmost or the bottom exit is rightmost.
Connecting the right and left exits is a similar process. Build out right and left until a random spot in the 2-D array. Connect the built-out paths depending on wether the right exit needs to be built down, or the left exit needs to be built down.

place_buildings: Start by selecting a random row and random column to place the buildings on. First place the pokemart with the randomly selected row. Find the first instance of a road, and place the building behind us. Because we are finding the first instance of the road, we can place the building behind us without verifying it.
We do the same thing with the pokecenter, except now we choose a column, and iterate down the column to the first road. Finally, placing the road behind us.
* The rows and column we choose to place our building needs to not be on an "exit" row or column for this to work. This depends on "crossing" a path, which will always happen if we aren't iterating down a path.  * Finally, I added a check to see if the chosen row and column are within 3 spaces of each other. If they are, generate another random column, as we could accidentally overlap the mart and center if they are close to each other.

fill_blank_space: Lastly, we will mix up the areas with nothing assigned to them. There is a 90% chance that nothing will happen to the space. A 7% chance it will become a tree. And a 3% chance that the space will turn into a rock.

print_map(): Now that everything is assigned, iterate over the map. Use the switch case on every part of the 2-D array, and print out the corresponding map element.
* I realized that I was accessing the X dimension first then the Y dimension when I was creating the 2-D array (array[X][Y]). I'm not sure if I'm straight up not allowed to do this, because everything still works. In the future, I'll try to make array accessing the Y dimension first (array[Y][X]), as Jeremy showed in class.
